// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
struct Ray {
    float3 origin;
    float3 dir;
};

struct ShapeData
{
    int type;
    float3 position;
    float3 scale;
    float3 rot;
    float3 ambient;
    float4 diffuse;
    float3 specular;
};

struct ReturnData
{
    float dist;
    float3 ambient;
    float4 diffuse;
    float3 specular;
};

struct LightData {
    int type;
    float3 position;
    float3 scale;
    float3 rot;
    float4 color;
    float3 forward;
    float cutOffAngle;
};

static const float MAX_DIST = 100;
static const float THRESHOLD = 0.001;

RWTexture2D<float4> dest;
Texture2D<float4> source;

float Resolution;
float4x4 CamToWorldMatrix;
float4x4 InverseProjMatrix;
StructuredBuffer<ShapeData> shapes;
int shapesLen;

StructuredBuffer<LightData> lights;
int lightsLen;

float3 light;

float4x4 GetRotateX(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return float4x4(
        float4(1, 0, 0,0),
        float4(0, c, -s,0),
        float4(0, s, c,0),
        float4(0, 0, 0, 1)
    );
}

float4x4 GetRotateY(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return float4x4(
        float4(c, 0, s, 0),
        float4(0, 1, 0,0),
        float4(-s, 0, c,0),
        float4(0,0,0,1)
    );
}

float4x4 GetRotateZ(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return float4x4(
        float4(c, -s, 0,0),
        float4(s, c, 0,0),
        float4(0, 0, 1,0),
        float4(0, 0, 0, 1)
    );
}

Ray CreateRay(float3 origin, float3 dir) {
    Ray ray;
    ray.origin = origin;
    ray.dir = dir; 
    return ray;
}

Ray CameraRay(float2 xy) {
    Ray ray;
    // Get cam origin in world coord
    float3 origin = mul(CamToWorldMatrix, float4(0, 0, 0, 1)).xyz;
    // Get position of pixel in camera coord
    float3 dir = mul(InverseProjMatrix, float4(xy, 0, 1)).xyz;
    // Get positon of pixel in world coord
    dir = mul(CamToWorldMatrix, float4(dir, 0)).xyz;
    dir = normalize(dir);
    return CreateRay(origin, dir);

}

float SDFBox(float3 p, float3 origin, float3 size) {
    float3 o = abs(p - origin) - size;
    float ud = length(max(o, 0));
    float n = max(max(min(o.x, 0), min(o.y, 0)), min(o.z, 0));
    return ud + n;
}

float SDFSphere(float3 p, float3 origin, float radius) {
    return distance(p, origin) - radius;
}

float GetShapeSDF(ShapeData s, float3 p) {
    float dist;
    float4 samplePointWithRotation = float4(p,1.0);


    // Unity default rotation order is Z-X-Y: https://docs.unity3d.com/Packages/com.unity.mathematics@0.0/api/Unity.Mathematics.math.RotationOrder.html#:~:text=Unity%20default%20rotation%20order.,finally%20around%20the%20y%20axis.&text=Extrinsic%20rotation%20around%20the%20x,finally%20around%20the%20z%20axis.&text=Extrinsic%20rotation%20around%20the%20x%20axis%2C%20then%20around%20the%20z,finally%20around%20the%20y%20axis.
    samplePointWithRotation = mul(samplePointWithRotation, GetRotateY(s.rot.y));
    samplePointWithRotation = mul(samplePointWithRotation, GetRotateX(s.rot.x));
    samplePointWithRotation = mul(samplePointWithRotation, GetRotateZ(s.rot.z));
    switch (s.type) {
        case 0:
            dist = SDFSphere(samplePointWithRotation.xyz, s.position, s.scale.x);
            break;
        case 1:
            dist = SDFBox(samplePointWithRotation.xyz,s.position,s.scale);
            break;
        default:
            dist = MAX_DIST;
            break;
    }
    return dist;
}

ReturnData GetClosestShapeData(float3 p) {
    float closestDist = MAX_DIST;
    float3 closestColor = float3(0,0,0);
    ReturnData result = { closestDist, float3(0,0,0),float4(0,0,0,1), float3(0,0,0) };
    for (int i = 0; i < shapesLen; i++) {
        ShapeData s = shapes[i];
        
        float distToShape = GetShapeSDF(s, p);
        if (distToShape < closestDist) {
            result.dist = distToShape; 
            result.ambient = s.ambient;
            result.diffuse = s.diffuse;
            result.specular = s.specular;
            closestDist = distToShape;
            closestColor = s.diffuse.rgb;
        }
    }
    return result;
}

float3 EsitmateNormal(float3 p) {
    return normalize(float3(
        GetClosestShapeData(float3(p.x + THRESHOLD, p.yz)).dist - GetClosestShapeData(float3(p.x - THRESHOLD, p.yz)).dist,
        GetClosestShapeData(float3(p.x, p.y + THRESHOLD, p.z)).dist - GetClosestShapeData(float3(p.x, p.y - THRESHOLD, p.z)).dist,
        GetClosestShapeData(float3(p.xy, p.z + THRESHOLD)).dist - GetClosestShapeData(float3(p.xy, p.z - THRESHOLD)).dist
        ));
}

float4 BlinnPhong(float3 p, float3 orig,float3 L,float3 lightColor,float3 ambient ,float3 matDiffuse, float3 specular) {
    float3 lightDir = -L;
    float3 E = normalize(orig - p);
    float3 H = normalize(lightDir + E);
    float3 N = EsitmateNormal(p);

    float4 amb = float4(ambient, 1.0);

    float Kd = max(dot(N, lightDir), 0.0);
    float4 diffuse = Kd * float4(matDiffuse, 1.0);

    float Ks = pow(max(dot(N, H), 0.0), 100.0);
    float4 spec = Ks * float4(specular, 1.0);

    if (dot(lightDir, N) < 0.0) {
        spec = float4(0, 0, 0, 1);
    }

    float4 color =  clamp((diffuse + spec)*float4(lightColor,1.0f), float4(0.0f, 0.0f, 0.0f, 0.0f),float4(1.0f, 1.0f, 1.0f, 1.0f));
    color.w = 1;
    return color;

}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    //Default to showing the scene normally
    dest[id.xy] = source[id.xy];
    uint width, height;
    dest.GetDimensions(width, height);
    float x = id.x / width * 2.0f - 1.0f;
    float y = id.y/ height * 2.0f - 1.0f;
    float2 xy = id.xy / float2(width, height) * 2 - 1;;
    Ray ray = CameraRay(xy);
    float steps = 0;
    int it = 0;
    ReturnData closestData;
    
    while (steps < MAX_DIST ) {
        
        closestData = GetClosestShapeData(ray.origin);
        
        //dest[id.xy] = float4(closestData.w,1,1, 1);
        //dest[id.xy] = float4(ray.origin * closestData.w, 1);
        if (closestData.dist < THRESHOLD) {
            
            dest[id.xy] = float4(closestData.diffuse.rgb, 1);
            float4 fColor = float4(0,0,0,1);
            for (int i = 0; i < lightsLen; i++) {
                if (lights[i].type == 0) { //Directional
                    fColor += BlinnPhong(ray.origin + ray.dir * closestData.dist, ray.origin,normalize(lights[i].forward),lights[i].color, closestData.ambient.rgb, closestData.diffuse.rgb, closestData.specular.rgb);
                }
                else if (lights[i].type == 1) { //Point

                }
                else if (lights[i].type == 2) { //Spot

                }
                else {
                    fColor += lights[i].color * float4(closestData.ambient,1.0);
                }
            }
            dest[id.xy] = fColor;
            break;
        }
        //March
        ray.origin = ray.origin + ray.dir * closestData.dist;
        
        steps += closestData.dist;
        it++;
    }
    //Result[id.xy] = float4(ray.dir * 0.5f + 0.5f, 1.0f);
    //Result[id.xy] = float4(x,y,0.0, 0.0);
    //Go through all shapes and find distance and Color 
    //if distance is smaller than threshold output the pixel
    //if greater move the distance in dir of ray
}
