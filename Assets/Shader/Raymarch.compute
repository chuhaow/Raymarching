// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

float3 EsitmateNormal(float3 p);

struct Ray {
    float3 origin;
    float3 dir;
};

struct ShapeData
{
    int type;
    int behaviour;
    float3 position;
    float3 scale;
    float3 rot;
    float3 normal;
    float3 ambient;
    float4 diffuse;
    float3 specular;
    float blend;
    float power;
};

struct ReturnData
{
    float dist;
    float3 ambient;
    float4 diffuse;
    float3 specular;
};

struct LightData {
    int type;
    float3 position;
    float3 scale;
    float3 rot;
    float4 color;
    float3 forward;
    float cutOffAngle;
};

static const float MAX_DIST = 100;
static const float THRESHOLD = 0.0001;

RWTexture2D<float4> dest;
Texture2D<float4> source;

float Resolution;
float4x4 CamToWorldMatrix;
float4x4 InverseProjMatrix;
StructuredBuffer<ShapeData> shapes;
int shapesLen;

StructuredBuffer<LightData> lights;
int lightsLen;

float3 light;

float r;

float4x4 GetRotateX(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return float4x4(
        float4(1, 0, 0,0),
        float4(0, c, -s,0),
        float4(0, s, c,0),
        float4(0, 0, 0, 1)
    );
}

float4x4 GetRotateY(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return float4x4(
        float4(c, 0, s, 0),
        float4(0, 1, 0,0),
        float4(-s, 0, c,0),
        float4(0,0,0,1)
    );
}

float4x4 GetRotateZ(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return float4x4(
        float4(c, -s, 0,0),
        float4(s, c, 0,0),
        float4(0, 0, 1,0),
        float4(0, 0, 0, 1)
    );
}

Ray CreateRay(float3 origin, float3 dir) {
    Ray ray;
    ray.origin = origin;
    ray.dir = dir; 
    return ray;
}

Ray CameraRay(float2 xy) {
    Ray ray;
    // Get cam origin in world coord
    float3 origin = mul(CamToWorldMatrix, float4(0, 0, 0, 1)).xyz;
    // Get position of pixel in camera coord
    float3 dir = mul(InverseProjMatrix, float4(xy, 0, 1)).xyz;
    // Get positon of pixel in world coord
    dir = mul(CamToWorldMatrix, float4(dir, 0)).xyz;
    dir = normalize(dir);
    return CreateRay(origin, dir);

}

float SDFBox(float3 p, float3 origin, float3 size) {
    float3 o = abs(p - origin) - size;
    float ud = length(max(o, 0));
    float n = max(max(min(o.x, 0), min(o.y, 0)), min(o.z, 0));
    return ud + n;
}

float SDFSphere(float3 p, float3 origin, float radius) {
    float displacement = 0;//sin(r * p.x) *  cos( r * p.y) * cos( r * p.z);//sin(r * p.x)*cos(r * p.x) * sin(r * p.y) * cos(r * p.y* p.y) * sin(r * p.z) * cos(r * p.z) * 0.25;
    return distance(p, origin) - radius + displacement;
}

float SDFPlane(float3 p, float n, float h) {
    n = normalize(n);
    return dot(p, n) + h;
}

float SDFFractal(float3 pos, float3 origin, float3 power) {
    float3 z = pos - origin;
    float dr = 1.0;
    float r = 0.0;
    for (int i = 0; i < 15; i++) {
        r = length(z);
        if (r > 2) break;

        // convert to polar coordinates
        float theta = acos(z.z / r);
        float phi = atan2(z.y, z.x);
        dr = pow(r, power - 1.0) * power * dr + 1.0;

        // scale and rotate the point
        float zr = pow(r, power);
        theta = theta * power;
        phi = phi * power;

        // convert back to cartesian coordinates
        z = zr * float3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
        z -= origin;
        z += pos;
    }
    return 0.5 * log(r) * r / dr;
}

float2 SmoothMin(float a, float b, float k)
{
    float h = max(k - abs(a - b), 0.0) / k;
    float m = h * h * h * 0.5;
    float s = m * k * (1.0 / 3.0);
    return (a < b) ? float2(a - s, m) : float2(b - s, 1.0 - m);
}


float GetShapeSDF(ShapeData s, float3 p) {
    float dist;
    float4 samplePointWithRotation = float4(p,1.0);


    // Unity default rotation order is Z-X-Y: https://docs.unity3d.com/Packages/com.unity.mathematics@0.0/api/Unity.Mathematics.math.RotationOrder.html#:~:text=Unity%20default%20rotation%20order.,finally%20around%20the%20y%20axis.&text=Extrinsic%20rotation%20around%20the%20x,finally%20around%20the%20z%20axis.&text=Extrinsic%20rotation%20around%20the%20x%20axis%2C%20then%20around%20the%20z,finally%20around%20the%20y%20axis.
    samplePointWithRotation = mul(samplePointWithRotation, GetRotateY(s.rot.y));
    samplePointWithRotation = mul(samplePointWithRotation, GetRotateX(s.rot.x));
    samplePointWithRotation = mul(samplePointWithRotation, GetRotateZ(s.rot.z));
    switch (s.type) {
        case 0:
            dist = SDFSphere(samplePointWithRotation.xyz, s.position, s.scale.x);
            break;
        case 1:
            dist = SDFBox(samplePointWithRotation.xyz,s.position,s.scale);
            break;
        case 2:
            dist = SDFFractal(samplePointWithRotation.xyz, s.position,s.power);
            break;
        default:
            dist = MAX_DIST;
            break;
    }
    return dist;
}

ReturnData GetMarchData(float3 p) {
    float closestDist = MAX_DIST;
    float4 lastColor = 1;
    float3 closestColor = float3(0, 0, 0);
    ReturnData result = { closestDist, float3(0,0,0),lastColor, float3(0,0,0) };
    for (int i = 0; i < shapesLen; i++) {
        ShapeData s = shapes[i];
        float distToShape = GetShapeSDF(s, p);
        switch (s.behaviour) {
            case 0: //Default
                if (distToShape < closestDist) {
                    result.dist = distToShape;
                    result.ambient = s.ambient;
                    result.diffuse = s.diffuse;
                    result.specular = s.specular;
                }

                break;
            case 1: // BLEND
                float2 smin = SmoothMin(closestDist, distToShape, s.blend);
                float4 blendColor = lerp(lastColor, s.diffuse, smin.y);
                result.dist = smin.x;
                result.ambient = s.ambient;
                result.diffuse = blendColor;
                result.specular = s.specular;
                break;
                
            case 2: // WRAP
                if (distToShape < closestDist) {
                    float2 smin = SmoothMin(distToShape, closestDist, 0.6f);
                    result.dist = smin.x;
                    result.ambient = s.ambient;
                    result.diffuse = s.diffuse;
                    result.specular = s.specular;
                }
                break;
                
            case 3: // COMPLEMENT
                if (-distToShape > closestDist) {
                    result.dist = -distToShape;
                    result.ambient = s.ambient;
                    result.diffuse = s.diffuse;
                    result.specular = s.specular;
                }
                break;
            case 4: // INTERSECTION
                if (distToShape > closestDist) {
                    result.dist = distToShape;
                    result.ambient = s.ambient;
                    result.diffuse = s.diffuse;
                    result.specular = s.specular;
                }   
                break;
            default: break;
        }
        lastColor = result.diffuse;
        closestDist = result.dist;
        
    }
    return result;
}

float3 EsitmateNormal(float3 p) {
    return normalize(float3(
        GetMarchData(float3(p.x + THRESHOLD, p.yz)).dist - GetMarchData(float3(p.x - THRESHOLD, p.yz)).dist,
        GetMarchData(float3(p.x, p.y + THRESHOLD, p.z)).dist - GetMarchData(float3(p.x, p.y - THRESHOLD, p.z)).dist,
        GetMarchData(float3(p.xy, p.z + THRESHOLD)).dist - GetMarchData(float3(p.xy, p.z - THRESHOLD)).dist
        ));
}


float4 BlinnPhong(float3 p, float3 orig,float3 L,float3 lightColor,float3 ambient ,float3 matDiffuse, float3 specular) {
    float3 lightDir = -L;
    float3 E = normalize(orig - p);
    float3 H = normalize(lightDir + E);
    float3 N = EsitmateNormal(p);

    float Kd = max(dot(N, lightDir), 0.0);
    float4 diffuse = Kd * float4(matDiffuse, 1.0);

    float Ks = pow(max(dot(N, H), 0.0), 100.0);
    float4 spec = Ks * float4(specular, 1.0);

    if (dot(lightDir, N) < 0.0) {
        spec = float4(0, 0, 0, 1);
    }

    float4 color =  clamp((diffuse + spec)*float4(lightColor,1.0f), float4(0.0f, 0.0f, 0.0f, 0.0f),float4(1.0f, 1.0f, 1.0f, 1.0f));
    color.w = 1;
    return color;

}

float CalShadow(Ray ray, float shadowBias, float distToLight, float k) {
    float result = 1.0f;
    float rayDist = 0.00001f;
    
    ReturnData marchData;
    while (rayDist < distToLight) {
        marchData = GetMarchData(ray.origin);
        float dist = marchData.dist;

        if (dist < THRESHOLD) {
            return 0.0f;
        }
        result = min(result, k * (dist / rayDist));
        ray.origin += ray.dir * dist;
        rayDist += dist;
    }
    return result;
}


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{

    //Default to showing the scene normally
    dest[id.xy] = source[id.xy];
    uint width, height;
    dest.GetDimensions(width, height);
    float x = id.x / width * 2.0f - 1.0f;
    float y = id.y/ height * 2.0f - 1.0f;
    float2 xy = id.xy / float2(width, height) * 2 - 1;;
    Ray ray = CameraRay(xy);
    float steps = 0;
    int it = 0;
    ReturnData closestData;
    
    while (steps < MAX_DIST ) {
        
        closestData = GetMarchData(ray.origin);
        
        //dest[id.xy] = float4(closestData.w,1,1, 1);
        //dest[id.xy] = float4(ray.origin * closestData.w, 1);
        if (closestData.dist < THRESHOLD) {
            
            //dest[id.xy] = float4(closestData.diffuse.rgb, 1);
            float4 fColor = float4(0,0,0,1);
            float3 p = ray.origin + ray.dir * closestData.dist;
            float3 normal = EsitmateNormal(p);
            for (int i = 0; i < lightsLen; i++) {
                if (lights[i].type == 0) { //Directional
                    float3 L = normalize(lights[i].forward);
                    float4 tempColor = BlinnPhong(p, ray.origin, L, lights[i].color, closestData.ambient.rgb, closestData.diffuse.rgb, closestData.specular.rgb);

                    //Shadow
                    float3 dirToLight = -L;
                    Ray shadowRay = CreateRay(p + (normal * THRESHOLD * 100), dirToLight);
                    float distToLight = MAX_DIST;
                    float shadow = CalShadow(shadowRay, 2, distToLight, 8);//CalculateShadow(shadowRay, distToLight);
                    
                    fColor += tempColor * shadow ;
                }
                else if (lights[i].type == 1) { //Point
                    float3 L = normalize(p - lights[i].position);
                    float4 tempColor = BlinnPhong(p, ray.origin, L, lights[i].color, closestData.ambient.rgb, closestData.diffuse.rgb, closestData.specular.rgb);

                    //Shadow
                    float3 dirToLight = -L;
                    Ray shadowRay = CreateRay(p + (normal * THRESHOLD * 500), dirToLight);
                    float distToLight = MAX_DIST;
                    float shadow = CalShadow(shadowRay, 2, distToLight, 8);//CalculateShadow(shadowRay, distToLight);

                    fColor += tempColor * shadow;
                }
                else if (lights[i].type == 2) { //Spot
                    float3 L = normalize(p - lights[i].position);
                    float3 dir = normalize(lights[i].forward);
                    float cosAngle = dot(L, dir);
                    float angle = acos(cosAngle);
                    angle *= (180.0f / 3.14159f);
                    if (angle < lights[i].cutOffAngle) {
                        float4 tempColor = BlinnPhong(p, ray.origin, L, lights[i].color, closestData.ambient.rgb, closestData.diffuse.rgb, closestData.specular.rgb);

                        //Shadow
                        float3 dirToLight = -L;
                        Ray shadowRay = CreateRay(p + (normal * THRESHOLD * 100), dirToLight);
                        float distToLight = MAX_DIST;
                        float shadow = CalShadow(shadowRay, 2, distToLight, 8);//CalculateShadow(shadowRay, distToLight);

                        fColor += tempColor * shadow;
                    }
                }
                else {
                    fColor += lights[i].color * float4(closestData.diffuse.rgb,1.0);
                }
            }
            float ao = 1 - float(it) / (255 - 1);
            dest[id.xy] = fColor;
            break;
        }
        //March
        ray.origin = ray.origin + ray.dir * closestData.dist;
        
        steps += closestData.dist;
        it++;
    }
    //Result[id.xy] = float4(ray.dir * 0.5f + 0.5f, 1.0f);
    //Result[id.xy] = float4(x,y,0.0, 0.0);
    //Go through all shapes and find distance and Color 
    //if distance is smaller than threshold output the pixel
    //if greater move the distance in dir of ray
}
