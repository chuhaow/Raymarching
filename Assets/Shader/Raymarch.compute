// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

float Resolution;
float4x4 CamToWorldMatrix;
float4x4 InverseProjMatrix;

struct Ray {
    float3 origin;
    float3 dir;
};

struct ShapeData
{
    int type;
    float4 color;
};

StructuredBuffer<ShapeData> shapes;

Ray CreateRay(float3 origin, float3 dir) {
    Ray ray;
    ray.origin = origin;
    ray.dir = dir; 
    return ray;
}

Ray CameraRay(float2 xy) {
    Ray ray;
    // Get cam origin in world coord
    float3 origin = mul(CamToWorldMatrix, float4(0, 0, 0, 1)).xyz;
    // Get position of pixel in camera coord
    float3 dir = mul(InverseProjMatrix, float4(xy, 0, 1)).xyz;
    // Get positon of pixel in world coord
    dir = mul(CamToWorldMatrix, float4(dir, 0)).xyz;
    dir = normalize(dir);
    return CreateRay(origin, dir);

}

float SDFBox(float3 p, float origin, float size) {
   
}

float SDFSphere(float3 p, float origin, float radius) {
    return distance(p, origin) - radius;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);
    float x = id.x + 0.5f / width * 2.0f - 1.0f;
    float y = id.y + 0.5f / height * 2.0f - 1.0f;
    float2 xy = float2(x, y);
    Ray ray = CameraRay(xy);
    Result[id.xy] = float4(ray.dir * 0.5f + 0.5f, 1.0f);
    //Result[id.xy] = float4(x,y,0.0, 0.0);
    //Go through all shapes and find distance and Color 
    //if distance is smaller than threshold output the pixel
    //if greater move the distance in dir of ray
}
